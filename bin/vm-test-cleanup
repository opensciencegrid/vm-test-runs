#!/bin/bash
#
# Delete old VMU test runs from `/var/www/html` and `/osgtest/runs` based on
# free disk space on `/var/www/html`.  (I am watching that instead of
# `/osgtest/runs` because `/var/www/html` is on a smaller partition.)
#

WATCHED_DIRECTORY=/var/www/html
RUNS_DIRECTORY=/osgtest/runs
HIGH_WATER_MARK=90
LOW_WATER_MARK=85
KEEP_DIRS=5


fail () {
    set +exu
    local ret="${1}"
    shift
    echo -e "${@}" >&2
    exit "${ret}"
}


usage_pct() {
    df -P /var/www/html | tail -1 | awk '{print $5}' | tr -d '%'
}


set -eu

# Check current usage of the filesystem containing /var/www/html
cur=$(usage_pct)
[[ -n $cur ]] || fail 3 "Could not determine usage"

# Only start deleting if usage is above the high water mark
if [ "$cur" -lt $HIGH_WATER_MARK ]; then
    echo "No cleanup necessary: usage is ${cur}%"
    exit 0
fi

cd "$WATCHED_DIRECTORY" || fail 4 "Could not enter $WATCHED_DIRECTORY"

# Timestamp pattern: %Y%m%d-%H%M (e.g. 20250101-1230)
ts_pattern='20[0-9][0-9][01][0-9][0-3][0-9]-[0-2][0-9][0-5][0-9]'

count=0
# Delete oldest timestamped directories until usage drops below the low water mark
while [ "$cur" -ge $LOW_WATER_MARK ]; do
    # note: do not quote $ts_pattern below
    dirs=$(ls -1d $ts_pattern 2>/dev/null | sort)
    dir_count=$(wc -l <<<"${dirs}")
    if [[ ${dir_count} -le ${KEEP_DIRS} ]]
    then
        fail 5 "Exiting early because only ${dir_count} directories remain"
    fi
    oldest=$(head -n 1 <<<"${dirs}")

    # Ensure it's a directory before removing
    if [ -d "$oldest" ]; then
        rm -rf -- "$oldest"
        count=$((count + 1))
    fi

    # Also remove corresponding test run directory
    run_dir="${RUNS_DIRECTORY}/run-$oldest"
    if [ -d "$run_dir" ]; then
        rm -rf -- "$run_dir"
    fi

    # Recompute usage
    cur=$(usage_pct)
    if [ -z "$cur" ]; then
        break
    fi
done
echo "${count} directories deleted"
